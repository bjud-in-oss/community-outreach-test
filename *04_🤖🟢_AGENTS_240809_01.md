# Community Outreach Platform - DIY Coding Platform for Seniors
## Master Plan 2.0: Dubbelt Medvetandesystem Arkitektur

## Project Vision & Structure
Banbrytande DIY-kodningsplattform f칬r seniorer och kyrkliga gemenskaper. Systemet anv칛nder dubbel medvetandestruktur d칛r teknisk komplexitet helt abstraheras bort fr친n anv칛ndaren. Utvecklare: Mattias.

### K칛rnarkitektur: Dubbelt Medvetandesystem
**Den Medvetna Rondellen** (Frontend & Kommunikation):
- 100% oteknisk kommunikation med seniorer
- Empati-motor med Groq f칬r emotionella responser
- MCP-UI komponenter f칬r senior-v칛nliga gr칛nssnitt
- Spr친kprocessor f칬r naturlig spr친kinteraktion

**K칛rn-agenten** (Backend & Teknisk Implementation):
- LangChain orchestration f칬r agent reasoning
- LlamaIndex f칬r RAG och minneshantering  
- Jules/Smolagents integration som kontrollerade verktyg
- Vercel + Supabase infrastruktur

**ReAct Kommunikationsbrygga**:
- Strikta guardrails f칬r informationsseparation
- Strukturerad tanke/minne 칬verf칬ring
- S칛ker 칬vers칛ttning mellan medveten/k칛rn-agent

## AI Agent Communication System

### Jules Communication Protocol (DISCOVERED METHOD)
Jules can be communicated with through GitHub issue manipulation:

1. **Task Triggering**: Add "jules" label to any GitHub issue
2. **Task Restart**: Modify issue title (add "Try again") + remove/re-add "jules" label
3. **Context Updates**: Jules reads this AGENTS.md file for every task
4. **Progress Monitoring**: Jules comments on issues with updates
5. **Completion**: Jules creates pull requests when done

### Intelligent Agent Loop Architecture
The system operates in three intelligent phases:

**Phase 1: ACT ON ENVIRONMENT** (N칛rhet genom handling)
- Monitor GitHub issues for stuck Jules tasks
- Manipulate issue titles and labels to restart tasks
- Update AGENTS.md with new context and learnings
- Create new issues when needed

**Phase 2: ADAPT TO ENVIRONMENT** (N칛rhet genom anpassning)  
- Learn from Jules responses and behavior patterns
- Adjust communication strategies based on success/failure
- Update environment understanding

**Phase 3: PROCESS DEEPER** (Djup reflektion)
- Analyze memory patterns for insights
- Generate new strategies from historical data
- Optimize memory to prevent overflow
- Plan multi-step approaches

### Memory System (Dynamic Learning)
- **Interactions**: Jules communication history and outcomes
- **Patterns**: Behavioral patterns in Jules responses  
- **Strategies**: Successful approaches for different scenarios
- **Failures**: Learning opportunities from unsuccessful attempts
- **Environment**: Current state understanding and context

## Development Setup (Master Plan 2.0)

### Strategisk Teknisk Stack
**游리 Agent-ramverk**: LangChain (orchestration), LlamaIndex (RAG/minne)
**游댯 Infrastruktur**: Vercel (hosting), Supabase (databas/auth)  
**游리 LLM-leverant칬rer**: Groq (emotionell motor), Gemini API (kodgenerering)
**游댮 Specialist-verktyg**: Jules (kontrollerat verktyg), Smolagents (alternativ)

### Fasbaserad Utveckling: "Crawl, Walk, Run, Fly"
**Fas 0 (CRAWL)**: Infrastruktur & "Hello World" - Next.js + Vercel + Supabase
**Fas 1 (WALK)**: Funktionell k칛rn-agent - LangChain + LlamaIndex integration
**Fas 2 (RUN)**: Empatisk seniorupplevelse - MCP-UI + Groq emotionell motor
**Fas 3 (FLY)**: Autonom sj칛lvf칬rb칛ttrande agent - Metakognitiva f칬rm친gor

### Package Management & Scripts
- Use npm for package management
- Follow React functional component patterns with TypeScript
- Include TypeScript interfaces for all data structures
- Always include proper package.json scripts:
  - `"test": "jest --watchAll=false"`
  - `"test:watch": "jest --watch"`
  - `"build": "next build"`
  - `"dev": "next dev"`
  - `"start": "next start"`
  - `"load-docs": "node docs/research/documentation-loader.js"`
  - `"analyze-docs": "npm run load-docs && cat docs/research/analysis-report.md"`

## Testing Requirements
- Write unit tests for all components using Jest and React Testing Library
- Create test files with `.test.tsx` or `.spec.tsx` extension
- Place test files in `__tests__` directory or alongside components
- Test file structure example:
```typescript
import { render, screen } from '@testing-library/react'
import '@testing-library/jest-dom'
import ComponentName from './ComponentName'

describe('ComponentName', () => {
  it('renders correctly', () => {
    render(<ComponentName />)
    expect(screen.getByText('Expected Text')).toBeInTheDocument()
  })
})
```
- Always include Jest configuration in package.json:
```json
{
  "jest": {
    "testEnvironment": "jsdom",
    "setupFilesAfterEnv": ["<rootDir>/jest.setup.js"]
  }
}
```
- Create jest.setup.js with: `import '@testing-library/jest-dom'`

## Automation Instructions for Jules
When completing tasks:
1. Always create comprehensive, production-ready code
2. Include proper error handling and TypeScript types
3. Write tests for all new functionality
4. Follow established project patterns
5. Create detailed commit messages explaining changes
6. Auto-publish pull requests when task is complete

## Required Dependencies for New Projects
Always include these dependencies in package.json:
```json
{
  "devDependencies": {
    "@testing-library/react": "^13.4.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/user-event": "^14.4.3",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "@types/jest": "^29.5.5"
  }
}
```

## File Creation Standards
For every new component, always create:
1. The component file (e.g., `components/Button.tsx`)
2. The test file (e.g., `components/__tests__/Button.test.tsx`)
3. Export from index file if applicable
4. Update package.json scripts if missing

## Branch Management
- Use descriptive branch names (feature/task-description)
- Include issue number in branch name when applicable
- Ensure all tests pass before creating PR
