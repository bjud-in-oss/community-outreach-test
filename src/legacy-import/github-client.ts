import { Octokit } from '@octokit/rest';
import { AutomationConfig, GitHubIssue, GitHubComment, JulesTask } from './types.js';

export class GitHubClient {
  private octokit: Octokit;
  private config: AutomationConfig;
  private processedTasks: Set<number> = new Set();
  private checkedComments: Set<string> = new Set();

  constructor(config: AutomationConfig) {
    this.config = config;
    this.octokit = new Octokit({
      auth: config.githubToken,
    });
  }

  /**
   * Create a GitHub issue that will trigger Jules
   */
  async createJulesTask(task: Omit<JulesTask, 'id' | 'createdAt' | 'status'>): Promise<GitHubIssue> {
    const issue = await this.octokit.rest.issues.create({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      title: task.title,
      body: `${task.description}

**Auto-generated by Jules Automation Agent**
- Follow all guidelines in AGENTS.md
- Auto-publish PR when complete
- Include comprehensive tests
- Use TypeScript best practices`,
      labels: [this.config.julesLabel],
    });

    return {
      number: issue.data.number,
      title: issue.data.title,
      body: issue.data.body || '',
      labels: issue.data.labels.map(label => typeof label === 'string' ? label : label.name || ''),
      state: issue.data.state as 'open' | 'closed',
      comments: [],
    };
  }

  /**
   * Monitor issue for Jules comments and status updates
   */
  async monitorIssue(issueNumber: number): Promise<GitHubComment[]> {
    const comments = await this.octokit.rest.issues.listComments({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      issue_number: issueNumber,
    });

    return comments.data.map(comment => ({
      id: comment.id,
      user: comment.user?.login || 'unknown',
      body: comment.body || '',
      created_at: comment.created_at,
      isJulesComment: comment.user?.login === 'google-labs-jules[bot]' || 
                     comment.user?.login === 'google-labs-jules' || 
                     comment.user?.login === 'google-labs-julesbot',
    }));
  }

  /**
   * Check if Jules has completed the task by looking for PR link in comments
   */
  async checkTaskCompletion(issueNumber: number): Promise<{
    isComplete: boolean;
    prUrl?: string;
    status: 'pending' | 'planning' | 'executing' | 'completed' | 'failed';
  }> {
    const comments = await this.monitorIssue(issueNumber);
    const julesComments = comments.filter(c => c.isJulesComment);
    
    // Prevent duplicate processing by checking if we already processed this
    if (this.processedTasks.has(issueNumber)) {
      return {
        isComplete: true,
        status: 'completed',
        prUrl: `Already processed task #${issueNumber}`
      };
    }
    
    // Look for completion indicators in Jules comments
    for (const comment of julesComments.reverse()) {
      const commentKey = `${issueNumber}-${comment.id}`;
      
      // Skip if we've already checked this comment
      if (this.checkedComments.has(commentKey)) {
        continue;
      }
      
      this.checkedComments.add(commentKey);
      // Reduced debug logging
      if (comment.body.includes('successfully generated a solution') ||
          comment.body.includes('Ready for review') ||
          comment.body.includes('Ready for a review') ||
          comment.body.includes('waiting for you to review') ||
          comment.body.includes('A PR has been created') ||
          comment.body.includes('pull request') ||
          comment.body.includes('Changes can be reviewed')) {
        
        console.log(`✅ Task completion detected for #${issueNumber}`);
        
        // Extract PR URL if present
        const prMatch = comment.body.match(/https:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/\d+/);
        const reviewMatch = comment.body.match(/https:\/\/jules\.google\.com\/[^\s]+/);
        
        // If we have a Jules review URL, we need to find the actual GitHub PR
        // For now, we'll look for linked PRs in the issue
        let prUrl = prMatch?.[0];
        if (!prUrl && reviewMatch?.[0]) {
          // Try to find PR from issue events/timeline
          prUrl = await this.findLinkedPR(issueNumber);
        }
        
        // Mark as processed to prevent duplicate processing
        const finalPrUrl = prUrl || reviewMatch?.[0];
        this.processedTasks.add(issueNumber);
        
        return {
          isComplete: true,
          prUrl: finalPrUrl,
          status: 'completed'
        };
      }
      
      if (comment.body.includes('Jules is on it') || 
          comment.body.includes('When finished')) {
        return {
          isComplete: false,
          status: 'executing'
        };
      }
    }

    return {
      isComplete: false,
      status: 'pending'
    };
  }

  /**
   * Get all open issues with Jules label
   */
  async getActiveJulesTasks(): Promise<GitHubIssue[]> {
    const issues = await this.octokit.rest.issues.listForRepo({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      labels: this.config.julesLabel,
      state: 'open',
    });

    return Promise.all(issues.data.map(async issue => ({
      number: issue.number,
      title: issue.title,
      body: issue.body || '',
      labels: issue.labels.map(label => typeof label === 'string' ? label : label.name || ''),
      state: issue.state as 'open' | 'closed',
      comments: await this.monitorIssue(issue.number),
    })));
  }

  /**
   * Find linked PR from issue timeline/events
   */
  private async findLinkedPR(issueNumber: number): Promise<string | undefined> {
    try {
      // Look for recently created PRs that might be related to this issue
      const prs = await this.octokit.rest.pulls.list({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        state: 'open',
        sort: 'created',
        direction: 'desc',
        per_page: 10
      });

      // Find PR that references this issue number
      for (const pr of prs.data) {
        if (pr.body?.includes(`#${issueNumber}`) || 
            pr.body?.includes(`issue ${issueNumber}`) ||
            pr.title.toLowerCase().includes(`issue #${issueNumber}`)) {
          return pr.html_url;
        }
      }

      // If no direct reference, return the most recent PR (likely from Jules)
      if (prs.data.length > 0) {
        return prs.data[0].html_url;
      }

      return undefined;
    } catch (error) {
      console.warn(`Failed to find linked PR for issue #${issueNumber}:`, error);
      return undefined;
    }
  }

  /**
   * Close issue after task completion
   */
  async closeTask(issueNumber: number, reason: string = 'Task completed by Jules'): Promise<void> {
    await this.octokit.rest.issues.createComment({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      issue_number: issueNumber,
      body: `✅ **Task Completed**\n\n${reason}\n\n*Closed by Jules Automation Agent*`,
    });

    await this.octokit.rest.issues.update({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      issue_number: issueNumber,
      state: 'closed',
    });
  }
}