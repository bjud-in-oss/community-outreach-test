// REFACTORED FOR MASTER PLAN 2.0: GitHubClient.ts
// ORIGINAL: src/legacy-import/infrastructure/github-client.ts
// STATUS: Refaktorerad f√∂r Dual Consciousness Architecture
// INTEGRATION: Core Agent Tool f√∂r GitHub kommunikation

import { Octokit } from '@octokit/rest';
import { JulesToolConfig, GitHubIssue, GitHubComment, TaskTemplate } from './types.js';

/**
 * MASTER PLAN 2.0 GitHub Client
 * 
 * Refaktorerad f√∂r Dual Consciousness Architecture:
 * - Endast tillg√§nglig f√∂r Core Agent
 * - Integrerad med Jules Tool ecosystem
 * - Robust error handling med Communication Bridge integration
 * - Senior-friendly task creation via templates
 */
export class GitHubClient {
  private octokit: Octokit;
  private config: JulesToolConfig;
  private processedTasks: Set<number> = new Set();
  private checkedComments: Set<string> = new Set();

  constructor(config: JulesToolConfig) {
    this.config = config;
    this.octokit = new Octokit({
      auth: config.githubToken,
    });
  }

  /**
   * MASTER PLAN 2.0: Create Jules task with dual consciousness integration
   * 
   * @param task - Task template with Master Plan 2.0 extensions
   * @returns Promise<GitHubIssue>
   */
  async createJulesTask(task: TaskTemplate): Promise<GitHubIssue> {
    const enhancedDescription = this.enhanceTaskDescription(task);
    
    const issue = await this.octokit.rest.issues.create({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      title: task.title,
      body: enhancedDescription,
      labels: [this.config.julesLabel],
    });

    console.log(`‚úÖ Core Agent created Jules task: Issue #${issue.data.number}`);

    return {
      number: issue.data.number,
      title: issue.data.title,
      body: issue.data.body || '',
      labels: issue.data.labels.map(label => typeof label === 'string' ? label : label.name || ''),
      state: issue.data.state as 'open' | 'closed',
      comments: [],
    };
  }

  /**
   * MASTER PLAN 2.0: Enhance task description with architecture guidelines
   */
  private enhanceTaskDescription(task: TaskTemplate): string {
    const architectureGuidelines = `
**üé≠ MASTER PLAN 2.0 DUAL CONSCIOUSNESS ARCHITECTURE**

**Target Agent:** ${task.targetAgent || 'core'}
**Senior Instructions:** ${task.seniorInstructions || 'Maintain senior-friendly interface'}

**üèóÔ∏è ARCHITECTURE REQUIREMENTS:**
${task.technicalRequirements?.map(req => `- ${req}`).join('\n') || '- Follow Master Plan 2.0 patterns'}

**üéØ DUAL CONSCIOUSNESS COMPLIANCE:**
- **Conscious Agent:** Maintain senior-friendly interfaces
- **Core Agent:** Handle technical implementation
- **Communication Bridge:** Ensure proper guardrails
- **Testing:** Comprehensive test coverage required

---

${task.description}

---

**üöÄ IMPLEMENTATION GUIDELINES:**
- Follow Master Plan 2.0 architecture patterns
- Implement dual consciousness separation
- Auto-publish PR when complete
- Include comprehensive tests
- Maintain senior-friendly design

**Auto-generated by Master Plan 2.0 Core Agent**
    `;

    return architectureGuidelines;
  }

  /**
   * MASTER PLAN 2.0: Monitor Jules task progress with enhanced tracking
   * 
   * @param issueNumber - GitHub issue number
   * @returns Promise<GitHubComment[]>
   */
  async monitorIssue(issueNumber: number): Promise<GitHubComment[]> {
    try {
      const comments = await this.octokit.rest.issues.listComments({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        issue_number: issueNumber,
      });

      return comments.data.map(comment => ({
        id: comment.id,
        user: comment.user?.login || 'unknown',
        body: comment.body || '',
        created_at: comment.created_at,
        isJulesComment: this.isJulesComment(comment.user?.login || ''),
      }));
    } catch (error) {
      console.error(`‚ùå Core Agent failed to monitor issue #${issueNumber}:`, error);
      throw new Error(`Failed to monitor issue: ${error}`);
    }
  }

  /**
   * MASTER PLAN 2.0: Enhanced Jules comment detection
   */
  private isJulesComment(username: string): boolean {
    const julesUsernames = [
      'google-labs-jules[bot]',
      'google-labs-jules',
      'google-labs-julesbot',
      'jules-agent'
    ];
    
    return julesUsernames.includes(username.toLowerCase());
  }

  /**
   * MASTER PLAN 2.0: Check task completion with enhanced status tracking
   * 
   * @param issueNumber - GitHub issue number
   * @returns Promise with completion status and PR URL
   */
  async checkTaskCompletion(issueNumber: number): Promise<{
    isComplete: boolean;
    prUrl?: string;
    status: 'pending' | 'planning' | 'executing' | 'completed' | 'failed';
    seniorFriendlyStatus?: string;
  }> {
    // Prevent duplicate processing
    if (this.processedTasks.has(issueNumber)) {
      return {
        isComplete: true,
        status: 'completed',
        prUrl: `Already processed task #${issueNumber}`,
        seniorFriendlyStatus: 'Uppgiften √§r redan slutf√∂rd'
      };
    }

    try {
      const comments = await this.monitorIssue(issueNumber);
      const julesComments = comments.filter(c => c.isJulesComment);
      
      // Look for completion indicators
      for (const comment of julesComments.reverse()) {
        const commentKey = `${issueNumber}-${comment.id}`;
        
        if (this.checkedComments.has(commentKey)) {
          continue;
        }
        
        this.checkedComments.add(commentKey);
        
        // Check for completion patterns
        if (this.isCompletionComment(comment.body)) {
          console.log(`‚úÖ Core Agent detected task completion for #${issueNumber}`);
          
          const prUrl = this.extractPRUrl(comment.body) || await this.findLinkedPR(issueNumber);
          this.processedTasks.add(issueNumber);
          
          return {
            isComplete: true,
            prUrl: prUrl,
            status: 'completed',
            seniorFriendlyStatus: 'Uppgiften √§r slutf√∂rd och redo f√∂r granskning'
          };
        }
        
        // Check for execution status
        if (this.isExecutionComment(comment.body)) {
          return {
            isComplete: false,
            status: 'executing',
            seniorFriendlyStatus: 'Arbetet p√•g√•r'
          };
        }
      }

      return {
        isComplete: false,
        status: 'pending',
        seniorFriendlyStatus: 'V√§ntar p√• att b√∂rja'
      };
    } catch (error) {
      console.error(`‚ùå Core Agent failed to check task completion for #${issueNumber}:`, error);
      return {
        isComplete: false,
        status: 'failed',
        seniorFriendlyStatus: 'Ett problem uppstod'
      };
    }
  }

  /**
   * MASTER PLAN 2.0: Enhanced completion detection
   */
  private isCompletionComment(body: string): boolean {
    const completionPatterns = [
      'successfully generated a solution',
      'Ready for review',
      'Ready for a review',
      'waiting for you to review',
      'A PR has been created',
      'pull request',
      'Changes can be reviewed',
      'task completed',
      'implementation finished'
    ];
    
    return completionPatterns.some(pattern => 
      body.toLowerCase().includes(pattern.toLowerCase())
    );
  }

  /**
   * MASTER PLAN 2.0: Enhanced execution detection
   */
  private isExecutionComment(body: string): boolean {
    const executionPatterns = [
      'Jules is on it',
      'When finished',
      'working on',
      'implementing',
      'in progress'
    ];
    
    return executionPatterns.some(pattern => 
      body.toLowerCase().includes(pattern.toLowerCase())
    );
  }

  /**
   * MASTER PLAN 2.0: Extract PR URL from comment
   */
  private extractPRUrl(body: string): string | undefined {
    const prMatch = body.match(/https:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/\d+/);
    return prMatch?.[0];
  }

  /**
   * MASTER PLAN 2.0: Get all active Jules tasks with enhanced filtering
   * 
   * @returns Promise<GitHubIssue[]>
   */
  async getActiveJulesTasks(): Promise<GitHubIssue[]> {
    try {
      const issues = await this.octokit.rest.issues.listForRepo({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        labels: this.config.julesLabel,
        state: 'open',
      });

      console.log(`üìã Core Agent found ${issues.data.length} active Jules tasks`);

      return Promise.all(issues.data.map(async issue => ({
        number: issue.number,
        title: issue.title,
        body: issue.body || '',
        labels: issue.labels.map(label => typeof label === 'string' ? label : label.name || ''),
        state: issue.state as 'open' | 'closed',
        comments: await this.monitorIssue(issue.number),
      })));
    } catch (error) {
      console.error(`‚ùå Core Agent failed to get active tasks:`, error);
      throw new Error(`Failed to get active tasks: ${error}`);
    }
  }

  /**
   * MASTER PLAN 2.0: Enhanced PR discovery with intelligent matching
   */
  private async findLinkedPR(issueNumber: number): Promise<string | undefined> {
    try {
      const prs = await this.octokit.rest.pulls.list({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        state: 'open',
        sort: 'created',
        direction: 'desc',
        per_page: 10
      });

      // Find PR that references this issue
      for (const pr of prs.data) {
        if (this.prReferencesIssue(pr, issueNumber)) {
          console.log(`üîó Core Agent found linked PR: ${pr.html_url} for issue #${issueNumber}`);
          return pr.html_url;
        }
      }

      // Fallback: most recent PR (likely from Jules)
      if (prs.data.length > 0) {
        console.log(`üîó Core Agent using most recent PR as fallback: ${prs.data[0].html_url}`);
        return prs.data[0].html_url;
      }

      return undefined;
    } catch (error) {
      console.warn(`‚ö†Ô∏è Core Agent failed to find linked PR for issue #${issueNumber}:`, error);
      return undefined;
    }
  }

  /**
   * MASTER PLAN 2.0: Check if PR references issue
   */
  private prReferencesIssue(pr: any, issueNumber: number): boolean {
    const body = pr.body?.toLowerCase() || '';
    const title = pr.title.toLowerCase();
    
    const referencePatterns = [
      `#${issueNumber}`,
      `issue ${issueNumber}`,
      `issue #${issueNumber}`,
      `fixes #${issueNumber}`,
      `closes #${issueNumber}`,
      `resolves #${issueNumber}`
    ];
    
    return referencePatterns.some(pattern => 
      body.includes(pattern.toLowerCase()) || title.includes(pattern.toLowerCase())
    );
  }

  /**
   * MASTER PLAN 2.0: Close task with enhanced messaging
   * 
   * @param issueNumber - GitHub issue number
   * @param reason - Reason for closing
   */
  async closeTask(issueNumber: number, reason: string = 'Task completed by Master Plan 2.0 Core Agent'): Promise<void> {
    try {
      await this.octokit.rest.issues.createComment({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        issue_number: issueNumber,
        body: `‚úÖ **Task Completed - Master Plan 2.0**

${reason}

**üé≠ Dual Consciousness Status:**
- **Conscious Agent:** Senior-friendly interface maintained
- **Core Agent:** Technical implementation completed
- **Communication Bridge:** Guardrails verified

*Closed by Master Plan 2.0 Core Agent*`,
      });

      await this.octokit.rest.issues.update({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        issue_number: issueNumber,
        state: 'closed',
      });

      console.log(`‚úÖ Core Agent closed task #${issueNumber}: ${reason}`);
    } catch (error) {
      console.error(`‚ùå Core Agent failed to close task #${issueNumber}:`, error);
      throw new Error(`Failed to close task: ${error}`);
    }
  }

  /**
   * MASTER PLAN 2.0: Health check for GitHub connection
   */
  async healthCheck(): Promise<{
    connected: boolean;
    rateLimit?: any;
    error?: string;
  }> {
    try {
      const rateLimit = await this.octokit.rest.rateLimit.get();
      
      console.log(`‚úÖ Core Agent GitHub connection healthy. Rate limit: ${rateLimit.data.rate.remaining}/${rateLimit.data.rate.limit}`);
      
      return {
        connected: true,
        rateLimit: rateLimit.data
      };
    } catch (error) {
      console.error(`‚ùå Core Agent GitHub connection failed:`, error);
      return {
        connected: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}